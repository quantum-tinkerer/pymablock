\section{Benchmark}

\subsection{Comparison to other methods}

\co{Pymablock is not only efficient, but its implementation has potential
to be expanded to other settings, like time-dependent Hamiltonians, many-body
Hamiltonians, and continuum Hamiltonians.}
Because Pymablock supports a wide range of inputs and custom solvers for
Sylvester's equation, its application is not limited to the examples shown
here.
Pymablock can be used to find effective Hamiltonians for interacting systems,
infinitely-sized Hilbert spaces, and Hamiltonians with continuum degrees of
freedom, by providing Hamiltonians written in second quantization form.
This is advantageous over other methods, which are limited to pre-defining
an appropriate generator for the unitary transformation.
Similarly, this flexibility allows Pymablock to work with time-dependent
Hamiltonians, an extension that we leave for future work.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/benchmark_bandstructure.pdf}
    \caption{Benchmark of Pymablock against other methods.}
    \label{fig:benchmark_bandstructure}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/benchmark_matrix_products.pdf}
    \caption{Benchmark of Pymablock against other methods.}
    \label{fig:benchmark_matrix_products}
\end{figure}
\subsection{Time scaling}

\co{To demonstrate the efficiency of the implicit algorithm, we show its time
scaling as a function of Hamiltonian size.}
Do we plot the Kwant tutorial here? Is there a way to count matrix products for
example? maybe using a counter in the code?
Showing scaling for large implicit Hamiltonians.

\subsection{Error scaling}

Show error accumulation, show that the inverse of the transformation holds to numerical precision.
