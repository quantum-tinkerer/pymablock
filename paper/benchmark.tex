\section{Benchmark}
\label{sec:benchmark}

\subsection{Comparison to other methods}

\co{Pymablock is not only efficient, but its implementation has potential
to be expanded to other settings, like time-dependent Hamiltonians, many-body
Hamiltonians, and continuum Hamiltonians.}
Because Pymablock supports a wide range of inputs and custom solvers for
Sylvester's equation, its application is not limited to the examples shown
here.
Pymablock can be used to find effective Hamiltonians for interacting systems,
infinitely-sized Hilbert spaces, and Hamiltonians with continuum degrees of
freedom, by providing Hamiltonians written in second quantization form.
This is advantageous over other methods, which are limited to pre-defining
an appropriate generator for the unitary transformation.
Similarly, this flexibility allows Pymablock to work with time-dependent
Hamiltonians, an extension that we leave for future work.


\co{To demonstrate the efficiency of the implicit algorithm, we show its
time scaling compared to sparse diagonalizaton.}


The effective Hamiltonian is constructed for the $10$ lowest energy
states of a $52 \times 52$ 2D square lattice with a nearest-neighbor
hopping and random on-site potential.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/benchmark_bandstructure.pdf}
    \caption{
        Bandstructure of an effective Hamiltonian (black) compared to exact
        sparse diagonalization (gray).
        The time spent in sparse diagonalization for one value of $\delta \mu$
        (gray) is shown in the lowest panel.
        This is also a constant overhead for the construction of the effective
        Hamiltonian.
        The time spent in the LU decomposition of the Hamiltonian (red) is a
        one-time cost, together with the time spent into getting second
        and third orders.
        First and second order corrections are negligible, not shown.
        }
    \label{fig:benchmark_bandstructure}
\end{figure}

\co{}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/benchmark_matrix_products.pdf}
    \caption{
        (left) Matrix products scaling per order of $\tilde{\mathcal{H}}$.
        (right) ???
    }
    \label{fig:benchmark_matrix_products}
\end{figure}
\subsection{Time scaling}


\subsection{Error scaling}

Show error accumulation, show that the inverse of the transformation holds to numerical precision.
