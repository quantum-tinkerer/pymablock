\section{Constructing an effective model}

\co{We consider scenarios for which perturbation theory is useful.}
We illustrate the construction of effective models by considering several
representative examples.
The simplest application of effective models is the reduction of finite
symbolic Hamiltonians, which appear in the derivation of low energy
dispersions of materials.
Starting from a tight-binding model, one performs Taylor expansions of the
Hamiltonian near a $k$-point, and then eliminates several high energy
states~\cite{McCann_2013}.
In the study of superconducting qubits, for example, the Hamiltonian contains
several bosonic operators, so its Hilbert space is infinite-dimensional, and
the coupling between bosons makes the Hamiltonian impossible to diagonalize.
The effective qubit model describes the analytical dependence of qubit
frequencies and couplings on the circuit
parameters~\cite{Zhu_2013,Krantz_2019,Li_2020,Blais_2021,Sete_2021}.
This allows to design circuits that realize a desired qubit Hamiltonian, as
well ways to understand and predict qubit dynamics, for which computational
tools are being actively developed~\cite{Groszkowski_2021,Chitta_2022,Li_2022}.
Finally, mesoscopic quantum devices are described by a single particle tight
binding model with short range hoppings.
This produces a numerical Hamiltonian that is both big and sparse, which allows
to compute a few of its states but not the full spectrum~\cite{Melo_2023}.
Because only the low energy states contribute to observable properties,
deriving how they couple enables a more efficient simulation of the system's
behavior.

\co{We demonstrate how Pymablock solves these problems.}
Pymablock treats all the problems, including the ones above, using a unified
approach that only requires three steps:
%
\begin{itemize}
\item Define a Hamiltonian
\item Call \mintinline{python}|pymablock.block_diagonalize|
\item Request the desired order of the effective Hamiltonian
\end{itemize}
%
The following code snippet shows how to use Pymablock to compute the fourth
order correction to an effective Hamiltonian $\tilde{\mathcal{H}}$:
%
\begin{minted}{python}
# Define perturbation theory
H_tilde, *_ = block_diagonalize([H_0, H_1], subspace_eigenvectors=[vecs_A, vecs_B])

# Request 4th order correction to the effective Hamiltonian
H_AA_4 = H_tilde[0, 0, 4]
\end{minted}
%
The function \mintinline{python}|block_diagonalize| interprets the Hamiltonian
$H_0 + H_1$ as a series with two terms, zeroth and first order, and calls the
block diagonalization routine.
This is the main function of Pymablock, and it is the only one that the user
ever needs to call.
Its first output is a multivariate series whose terms are different blocks and
orders of the transformed Hamiltonian.
Calling \mintinline{python}|block_diagonalize| only defines the computational
problem, whereas querying the elements of \mintinline{python}|H_tilde|
does the actual calculation of the desired order.
This interface treats arbitrary formats of Hamiltonians and system descriptions
on the same footing, and supports both numerical, and symbolic computations.

\subsection{k.p model of bilayer graphene}

\co{We use bilayer graphene to illustrate how to use Pymablock with analytic models.}

To illustrate how to use Pymablock with analytic models, we consider two layers
of graphene stacked on top of each other, as shown in Fig.~\ref{fig:bilayer}.
Our goal is to find the low energy model near the $\mathbf{K}$ point~\cite{McCann_2013}.
To do this, we first construct the tight-binding model Hamiltonian of bilayer
graphene.
%
\begin{figure}[!htbp]
\centering
\includegraphics[width=0.3125\linewidth]{figures/bilayer.pdf}
\caption[]{Crystal structure and hoppings of AB-stacked bilayer graphene.}
\label{fig:bilayer}
\end{figure}
%
The main features of the model are its 4-atom unit cell spanned by vectors
$\mathbf{a}_1 = (1/2, \sqrt{3}/2)$ and $\mathbf{a}_2=( -1/2, \sqrt{3}/2)$,
and with wave functions $\phi_{A,1}, \phi_{B,1}, \phi_{A,2}, \phi_{B,2}$, where
$A$ and $B$ indices are the two sublattices, and $1,2$ are the layers.
The model has hoppings $t_1$ and $t_2$ within and between the layers,
respectively, as shown in Fig.~\ref{fig:bilayer}.
We also include a layer-dependent onsite potential $\pm m$.

\co{We use sympy.}
We define the Bloch Hamiltonian using the Sympy package for symbolic Python
\cite{Meurer_2017}.
%
\begin{minted}{python}
t_1, t_2, m = sympy.symbols("t_1 t_2 m", real=True)
alpha = sympy.symbols(r"\alpha")

H = Matrix([
    [m, t_1 * alpha, 0, 0],
    [t_1 * alpha.conjugate(), m, t_2, 0],
    [0, t_2, -m, t_1 * alpha],
    [0, 0, t_1 * alpha.conjugate(), -m]]
)
\end{minted}

$$
H =
\begin{pmatrix}
m & t_1 \alpha & 0 & 0\\
t_1 \alpha^{*} & m & t_2 & 0\\
0 & t_2 & -m & t_1 \alpha\\
0 & 0 & t_1 \alpha^{*} & -m
\end{pmatrix}
$$
%
where $\alpha(\mathbf{k}) = 1 + e^{i \mathbf{k} \cdot \mathbf{a}_1} + e^{\mathbf{k} \cdot
\mathbf{a}_2}$, with $k$ the wave vector.
We consider $\mathbf{K}=(4\pi/3, 0)$ the reference point point in $\mathbf{k}$-space:
$\mathbf{k} = (4\pi/3 + k_x, k_y)$ because $\alpha(\mathbf{K}) = 0$, making
$k_x$ and $k_y$ small perturbations.
Additionally, we consider $m \ll t_2$ a perturbative parameter.

\co{We define the perturbative series}
To call \mintinline{python}|block_diagonalize|, we need to define the subspaces
for the block diagonalization, so we compute the eigenvectors of the
unperturbed Hamiltonian at the $\mathbf{K}$ point, $H(\alpha(\mathbf{K}) = m =
0)$.
Then, we substitute $\alpha(\mathbf{k})$ into the Hamiltonian, and call the
block diagonalization routine using that $k_x$, $k_y$, and $m$ are perturbative
parameters via the \mintinline{Python}|symbols| argument.
%
\begin{minted}{python}
vecs = H.subs({alpha: 0, m: 0}).diagonalize(normalize=True)[0]

H_tilde, U, U_adjoint = block_diagonalize(
    H.subs({alpha: alpha_k}),
    symbols=(k_x, k_y, m),
    subspace_eigenvectors=[vecs[:, :2], vecs[:, 2:]]
)
\end{minted}
%
The order of the variables in the perturbative series will be that of
\mintinline{python}{symbols}.
For example, requesting the term $\propto k_x^{i} k_y^{j} m^{l}$ from the
effective model is done by calling \mintinline{python}|H_tilde[0, 0, i, j, l]|,
where the first two indices are the block indices (AA).
The series of the unitary transformation $U$ and $U^\dagger$ are also defined,
and we may use them to transform other operators.

We collect corrections up to third order in momentum to compute the standard
quadratic dispersion of bilayer graphene and trigonal warping.
We query these terms from \mintinline{Python}|H_tilde| and those proportional
to mass to obtain the effective Hamiltonian (shown as produced by the
code)\footnote{The full code is available at
\url{https://pymablock.readthedocs.io/en/latest/tutorial/bilayer_graphene.html}.}:
%
{\small
\begin{gather}
\tilde{H}_{\textrm{eff}} =
\begin{bmatrix}
m & \frac{3 t_1^2}{4 t_2} ( - k_x^2 - 2ik_x k_y + k_y^2) \\
\frac{3 t_1^2}{4 t_2} ( - k_x^2 + 2ik_x k_y + k_y^2) & -m
\end{bmatrix} + \nonumber \\
\begin{bmatrix}
\frac{3 m t_1^2}{2 t_2^2} ( - k_x^2 - k_y^2) & \frac{\sqrt{3} t_1^2}{8 t_2} (k_x^3 - 5ik_x^2 k_y + 9 k_x k_y^2 + 3ik_y^3) \\
\frac{\sqrt{3} t_1^2}{8 t_2} (k_x^3 + 5ik_x^2 k_y + 9 k_x k_y^2 - 3ik_y^3) & \frac{3 m t_1^2}{2 t_2^2} (k_x^2 + k_y^2)
\end{bmatrix} \nonumber
\end{gather}
}
%
The first term is the standard quadratic dispersion of gapped bilayer
graphene.
The second term contains trigonal warping and the coupling between the gap and
momentum.
All the terms take less than two seconds in a personal computer to compute.

\subsection{Induced gap in a double quantum dot}

\co{Large systems pose an additional challenge due to the scaling of linear
algebra routines for large matrices.}
Large systems pose an additional challenge due to the cubic scaling of linear
algebra routines with matrix size.
To overcome this, Pymablock is equipped with an implicit method, which utilizes
the sparsity of the input and avoids the construction of the full transformed
Hamiltonian.
We illustrate the efficiency of this method by applying it to a system of two
quantum dots coupled to a superconductor between them, shown in
Fig.~\ref{fig:QD_spectrum}, and described by the Bogoliubov-de Gennes Hamiltonian:
%
\begin{equation}
    H_{BdG} =
    \begin{cases}
        (\mathbf{k}^2/2m - \mu_{sc}) \sigma_z + \Delta \sigma_x \quad & \text{for } L/3 \leq x \leq 2L/3, \\
        (\mathbf{k}^2/2m - \mu_n) \sigma_z \quad & \text{otherwise},
    \end{cases}
\end{equation}
where the Pauli matrices $\sigma_z$ and $\sigma_x$ act in the electron-hole
space, $\mathbf{k}$ is the 2D wave vector, $m$ is the effective mass, and
$\Delta$ the superconducting gap.

\co{We use Kwant to build the Hamiltonian of the system.}
We use the Kwant package~\cite{Groth_2014} to build the Hamiltonian of the
system~\footnote{The full code is available at
\url{https://pymablock.readthedocs.io/en/latest/tutorial/induced_gap.html}.},
which we define over a square lattice of $L \times W = 200 \times 40$ sites.
On top of this, we consider two perturbations: the barrier strength between the
quantum dots and the superconductor, $t_b$, and an asymmetry of
the dots potentials, $\delta \mu$.

The system is large: it is a sparse array of size $63042 \times 63042$, with
$333680$ non-zero elements, so even storing all the eigenvectors would take
$60$ GB of memory.
The perturbations are also sparse, with $632$, and $126084$ non-zero elements
for the barrier strength and the potential asymmetry, respectively.
The sparsity structure of the Hamiltonian and the perturbations is shown in the
left panel of Fig.~\ref{fig:QD_spectrum}, where we use a smaller system of $L
\times W = 8 \times 2$ for visualization.
Therefore, we use sparse diagonalization and compute only four eigenvectors of
the unperturbed Hamiltonian closest to zero energy, which are the Andreev
states of the quantum dots.
%
\inputminted[firstline=62, lastline=63]{python}{code_figures/lattice_system.py}
%
We now call the block diagonalization routine and provide the computed
eigenvectors.
%
\inputminted[firstline=65, lastline=65]{python}{code_figures/lattice_system.py}
%
Because we only provide the low energy subspace, Pymablock uses the implicit
method.
Calling \mintinline{python}|block_diagonalize| is now the most time consuming
step because it requires pre-computing several decompositions of the full
Hamiltonian.
It is, however, manageable and it only produces a constant overhead of less
than three seconds.

To compute the spectrum, we collect the lowest three orders in each parameter
in an appropriately sized tensor.
%
\inputminted[firstline=71, lastline=71]{python}{code_figures/lattice_system.py}
%
This takes two more seconds to run, and we can now compute the low energy
spectrum after rescaling the perturbative corrections by the magnitude of each
perturbation.
%
\inputminted[firstline=74, lastline=79]{python}{code_figures/lattice_system.py}
%
Finally, we plot the spectrum in Fig.~\ref{fig:QD_spectrum}.
%
\begin{figure}[h!]
\centering
\includegraphics[width=\linewidth]{figures/lattice_system.pdf}
\caption{
    Low energy spectrum of two quantum dots coupled to a superconductor for
    three values of the barrier strength $t_b \in (0, 0.5, 0.75)$.
}
\label{fig:QD_spectrum}
\end{figure}
%
As expected, the crossing at $E=0$ due to the dot asymmetry is lifted when the
dots are coupled to the superconductor.
In addition, we observe how the proximity gap of the dots increases with the
coupling strength.

In this example the total runtime of Pymablock would only allow us to compute
the spectrum at around $3$ points in the parameter space.
This demonstrates the speed of the implicit method and the efficiency of
Pymablock's algorithm.

\subsection{Circuit quantum electrodynamics}

\co{We illustrate the potential of Pymablock as a useful tool for the design
and control of superconducting qubits.}
Finally, we illustrate the potential of Pymablock as a useful too for the
design and control of superconducting qubits.
For this, we consider two capacitively coupled transmons~\cite{Klein_1974}
with the goal of finding the qubits effective Hamiltonian and the effective
coupling between them.
The Hamiltonian of the system is given by
%
\begin{equation}
    \label{eq:H_transmons}
    \mathcal{H} =\hbar \omega_1 a_1^\dagger a_1 + \hbar \omega_2 a_2^\dagger a_2 + \hbar g (a_1^\dagger a_2 + a_1 a_2^\dagger),
\end{equation}
%
where $a_1$ and $a_2$ are bosonic annihilation operators for each transmon,
$\omega_1$ and $\omega_2$ are the transmon frequencies, and $\alpha_1$ and
$\alpha_2$ are their anharmonicities.
The coupling strength $g$ is the term in the Hamiltonian that makes it
impossible to diagonalize, because it couples two infinitely dimensional
Hilbert spaces in a non-trivial way.
Therefore, we treat $g$ as a perturbative parameter.

\co{We truncate the Hamiltonian.}
Because our goal is to find the qubits Hamiltonian, the effective subspace is
the one spanned by the states $\ket{00}$, $\ket{01}$, $\ket{10}$, and
$\ket{11}$ of the two transmons.
All the other states are high energy states that belong to the $B$ subspace,
but there are infinitely many of them, and the higher they are in energy, the
less they contribute to the effective Hamiltonian.
Therefore, we truncate the Hilbert space to the $N$ lowest energy states of each
transmon and build a symbolic matrix Hamiltonian~\footnote{We build the matrix
Hamiltonian directly from the second quantization Hamiltonian in
Eq.~\eqref{eq:H_transmons} using Sympy's
\mintinline{python}|sympy.physics.quantum.boson.BosonOp| objects.}.
%
\begin{equation}
    \label{eq:H_transmons_matrix}
    {\small
    H_0 + H_1 = 
    \left[
        \begin{matrix}
            0 & 0 & 0 & - g & 0 & 0 & 0 & 0\\
            0 & \omega_{1} & g & 0 & 0 & 0 & - \sqrt{2} g & 0\\
            0 & g & \omega_{2} & 0 & 0 & 0 & 0 & - \sqrt{2} g\\
            - g & 0 & 0 & \omega_{1} + \omega_{2} & \sqrt{2} g & \sqrt{2} g & 0 & 0\\
            0 & 0 & 0 & \sqrt{2} g & 2 \alpha_{1} + 2 \omega_{1} & 0 & 0 & 0\\
            0 & 0 & 0 & \sqrt{2} g & 0 & 2 \alpha_{2} + 2 \omega_{2} & 0 & 0\\
            0 & - \sqrt{2} g & 0 & 0 & 0 & 0 & 2 \alpha_{1} + 2 \omega_{1} + \omega_{2} & 2 g\\
            0 & 0 & - \sqrt{2} g & 0 & 0 & 0 & 2 g & 2 \alpha_{2} + \omega_{1} + 2 \omega_{2}
        \end{matrix}
    \right]
    }
\end{equation}

%
Here we choose $N=2$ for each transmon, a number that depends on the
specifics of the problem.

\co{We call block diagonalize and compute the qubit Hamiltonian}
Now, we are ready to call \mintinline{python}|block_diagonalize| and compute the
effective Hamiltonian.
%
\inputminted[firstline=95, lastline=96]{python}{code_figures/transmons.py}
%

